---
title:  "Snort: Часть 4. Создание собственных правил для Snort"
excerpt: ""
date:   2017-02-01T04:00:00+03:00
categories:
   - Snort
tags:
   - Snort
   - IDS
   - IPS
   - Snort rules
author_profile: true
---

{% include toc icon="file-text" %}


## Синтаксис правил для Snort

Snort использует правила, написанные простым, но в то же время гибким и достаточно мощным языком. Большинство правил пишутся в одну строку, хотя могут занимать и несколько строк, в этом случае каждая строка, кроме последней, должна заканчиваться символом "\" (без кавычек). В более сложных случаях можно также вызывать другие программы, используя инструкцию включения.
Правила для Snort делятся на два вида:

* **Бесконтекстные (обычные)** - применяются для каждого пакета отдельно, без связи с другими пакетами
* **Контекстные (правила препроцессоров)** - применяться к той или иной совокупности (последовательности) пакетов.

Правила Snort состоят из **заголовка** (Rule Header) и **опций** (Rule Options). Заголовок содержит описание действия, протокол передачи данных, IP-адреса, сетевые маски и порты источника и назначения. После заголовка правила следует необязательная часть правила - его опции, они включают определение дополнительных критериев выполнения правила и определение дополнительных реагирующих действий. Они используются для организации более жесткой и направленной фильтрации траффика. Весь набор опций заключается в круглые скобки, сами опции отделяются друг от друг с помощью точки с запятой ";" (последняя опция в списке тоже должна заканчиваться этим символом). Ключевые слова (keywords) опций отделяются от своих аргументов (values) двоеточием ":". Структура правил Snort в общем случае выглядит следующим образом:

<table style="text-align: center;">
  <tbody>
    <tr>
      <th colspan="7">Заголовок</th>
      <th colspan="4">Опции</th>
    </tr>
    <tr>
      <td> Действие</td>
      <td> Протокол</td>
      <td> IP-адреса отправителей</td>
      <td> Порты отправителей</td>
      <td> Оператор направления</td>
      <td> IP-адреса получателей</td>
      <td> Порты получателей</td>
      <td> [Мета данные]</td>
      <td> [Данные в полезной нагрузке]</td>
      <td> [Данные в заголовке]</td>
      <td> [Действие после обнаружения]</td>
    </tr>
  </tbody>
</table>

Синтаксис записи правил Snort:

```
<Действие> <Протокол> <IP-адреса отправителей> <Порты отправителей> <Оператор направления> <IP-адреса получателей> <Порты получателей> (ключ_1 : значение_1; ключ_2 : значение_2; ... ключ_N : значение_N;)
```


### Заголовок правила

Допустимые параметры для каждого поля заголовка правил Snort:

#### Действия правила

| Действие | Описание                                                                                                    |
|----------|-------------------------------------------------------------------------------------------------------------|
| alert    | генерирует предупреждение, используя указанное предупреждение, и передаёт информацию системе журналирования |
| log      | просто протоколирует пакеты без предупреждений                                                              |
| pass     | игнорирует пакеты                                                                                           |
| activate | генерирует предупреждение, затем включает указанное динамическое правило                                    |
| dynamic  | остаётся пассивным, пока не активируется динамическим правилом, затем действует как log                     |

В режиме inline к предыдущим действиям добавляются дополнительные действия:

| Действие | Описание                                                                                                                                                                                           |
|----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| drop     | блокирует (отбрасывает) пакет и передаёт информацию системе журналирования                                                                                                                         |
| sdrop    | блокирует (отбрасывает) пакет и не использует систему журналирования                                                                                                                               |
| reject   | блокирует (отбрасывает) пакет, передаёт информацию системе журналирования, а затем посылает сегмент сброса TCP (TCP RST), если протокол TCP, или сообщение ICMP-порт недоступен, если протокол UDP |


Также можно создать свои собственные типы правил и связать один или несколько выходных модулей с ними. Можно затем использовать созданные типы правил в качестве действий в правилах Snort. В примере ниже создаётся тип правила, который будет регистрировать только tcpdump:

```
ruletype suspicious
{
    type log
    output log_tcpdump: suspicious.log
}
```


А в этом примере создаётся тип правила, регистрирующей и tcpdump, и syslog:

```
ruletype redalert
{
    type alert
    output alert_syslog: LOG_AUTH LOG_ALERT
    output log_tcpdump: suspicious.log
}
```

#### Протоколы

Обозначает протокол передачи данных. На данный момент Snort умеет анализировать на предмет подозрительного содержания/поведения 4 типа протоколов: TCP, UDP, ICMP, IP, соответственно, возможны 4 значения: tcp, udp, icmp или ip, что означает любой IP-протокол. В будущем, возможно, этот список пополнят и другие протоколы, к примеру, ARP, IGRP, GRE, OSPF, RIP, IPX и другие.

#### IP-адресация

Поскольку Snort не имеет встроенного механизма получения IP адреса, используя доменное имя, то нужно указывать конкретный IP адрес или же диапазон IP адресов. В этом параметре можно использовать маски. Адреса задаются в формате: IP/mask, где IP – IP-адрес сети или узла, mask – маска сети, которая задаётся как десятичное число, которое равняется числу единиц в двоичной маске. Например, для сетей класса C /24 (число 24 эквивалентное шестнадцатеричной маске FF.FF.FF.0), для сетей класса B - /16, также можно использовать маску /32 и другие. Здесь может применяться и отрицание (инвертирование), обозначаемое символом "!" (Например: !127.0.0.1). Если вместо IP адреса указать ключевое слово any, то это будет подразумевать абсолютно все хосты. Для указания списка можно использовать перечисление IP адресов через "," содержащихся в квадратных скобках. (Например: [212.116.1.1,10.10.1.0/24]). В качестве IP-адреса можно использовать переменные HOME_NET, EXTERNAL_NET и другие.

#### Порты

После IP адреса указывается номер порта, с которого отсылаются данные и на который приходят. Можно указать диапазон портов: 1:1024 (все порты в диапазоне от 1 до 1024 включая 1 и 1024). Часто используется оператор отрицания "!" (Например: !123:321 исключает все порты в диапазоне от 123 до 321). Если опущен один из параметров диапазона, например ":321" или "123:", то пропускаемый параметр принимает крайнее значение общего количества портов, то есть 0 или 65535.

#### Операторы направления

Оператор направления служит для обозначения направления траффика, для которого применяется правило, и обозначается "->" (знаком минуса и закрывающей угловой скобкой). IP-адрес и номер порта слева от оператора определяют источник траффика, а справа от него - назначение. Существует также оператор так называемой "двунаправленности" и обозначается "<>" (двумя угловыми скобками). Этот оператор говорит Snort рассматривать указанные пары адресов и портов в обе стороны, вне зависимости от того, кто является источником, а кто – получателем. Это удобно в тех случаях, когда нужно сохранить траффик от обеих сторон, например, в Telnet или POP3 сессиях. Важно отметить, что оператор "<-" не существует.




### Опции правила

Все опции можно разделить на четыре большие категории:

* **general (meta-data)** - данные опции предоставляют информацию о правиле, но никак не влияют на обнаружение;
* **payload** - данные опции позволяют искать информацию внутри полезной нагрузки (данных пользователя) пакетов и могут быть взаимосвязаны;
* **non-payload** - данные опции позволяют искать информацию внутри служебной (управляющей) информации о пакете (заголовке);
* **post-detection** - данные опции являются определёнными триггерами, указывающими задачи, которые необходимо осуществить после срабатывание правила.


#### General (meta-data)

* **msg**

  Указывает сообщение, текстовое описание сигнала тревоги (для экранирования используется символ "\"), которое будет выведено или же записано, используя систему журналирования.

  ***Синтаксис***: `msg:"<message text>";`

  ***Пример***:

* **reference**

  Указывает ссылки на online системы идентификации атак. Значениями этого поля могут быть ссылки на ресурсы bugtraq, cve, nessus, arachnids, mcafee и другие url. Идентификация осуществляется по SID номерам.

  Поддерживаемые системы:

    - bugtraq: http://www.securityfocus.com/bid/
    - cve: http://cve.mitre.org/cgi-bin/cvename.cgi?name=
    - nessus: http://cgi.nessus.org/plugins/dump.php3?id=
    - arachnids: (в данный момент не работает) http://www.whitehats.com/info/IDS
    - mcafee: http://vil.nai.com/vil/content/v_
    - osvdb: http://osvdb.org/show/osvdb/
    - msb: http://technet.microsoft.com/en-us/security/bulletin/
    - url: http://

  ***Синтаксис***: `reference:<id system>, <id>; [reference:<id system>, <id>;]`

  ***Пример***:

    ```
    alert tcp any any -> any 7070 (msg:"IDS411/dos-realaudio"; \
    flags:AP; content:"|fff4 fffd 06|"; reference:arachnids,IDS411;)
    ```

    ```
    alert tcp any any -> any 21 (msg:"IDS287/ftp-wuftp260-venglin-linux"; \
    flags:AP; content:"|31c031db 31c9b046 cd80 31c031db|"; \
    reference:arachnids,IDS287; reference:bugtraq,1387; \
    reference:cve,CAN-2000-1574;)
    ```


* **gid**

  Ключевое слово gid (generator id) используется для идентификации того, какая часть Snort генерирует событие, когда срабатывает конкретное правило. Например, gid равный 1 ассоциируется с подсистемой правил, а различные gid свыше 100 предназначены для определённых препроцессоров и декодеров. Опция gid является необязательной, и если она не определена в правиле, то по умолчанию она устанавливается равной 1, и правило будет являться частью общей подсистемы правил. Чтобы избежать потенциальных конфликтов с gid, определёнными в Snort, рекомендуется использовать значения начиная с 1000000. Для общих правил не рекомендуется использовать ключевое слово gid. Данная опция должна быть использована с опцией sid. Файл "etc/gen-msg.map" содержит больше информации о gid препроцессоров и декодеров.

  ***Синтаксис***: `gid:<generator id>;`

  ***Пример***:

    ```
    alert tcp any any -> any 80 (content:"BOB"; gid:1000001; sid:1; rev:1;)
    ```

* **sid**

  Ключевое слово sid (Snort id или иногда упоминается как signature id) используется для уникальной идентификации правил Snort. По значению его аргумента можно легко идентифицировать правило. Данное ключевое слово должно использоваться вместе с ключевым словом rev. Файл "sid-msg.map" содержит соответствие предупреждающих сообщений и идентификаторов правил Snort.
  Значения аргумента:

  < 100 зарезервировано разработчиками
  100 - 999.999 использованы в правилах, уже включенных в дистрибутив Snort
  >= 1.000.000 можно использовать для собственных правил

  ***Синтаксис***: `sid:<snort rules id>;`

  ***Пример***:

    ```
    alert tcp any any -> any 80 (content:"BOB"; sid:1000983; rev:1;)
    ```


* **rev**

  Указывает значение версии правила. С помощью REV интерпретатор правил Snort определяет версию написанного правила. Этот параметр используется в паре с SID.

  ***Синтаксис***: `rev:<revision integer>;`

  ***Пример***:

    ```
    alert tcp any any -> any 80 (content:"BOB"; sid:1000983; rev:1;)
    ```


* **classtype**

  Используется для присвоения категории атаки, к которой необходимо отнести правило, являющееся частью более общего класса атак. Snort предоставляет набор классов, которые используются предоставляемыми правилами по умолчанию. Классификация атак позволяет лучше организовать события, производимые Snort.
  Классификация атак представлена в файле "classification.conf". В файле используется следующий синтаксис для каждой записи:

  ```
  config classification: <имя класса>,<описание класса>,<приоритет по умолчанию>
  ```

  Приоритет 1 (high) является наиболее высоким, а 4 (very low) - самым низким. Также классификация типов атак представлена в таблице:

  <table>
    <tbody>
      <tr>
        <th> Тип класса </th>
        <th> Описание </th>
        <th> Приоритет </th>
      </tr>
      <tr>
        <td> attempted-admin </td>
        <td> Попытка получения прав администратора </td>
        <td> high </td>
      </tr>
      <tr>
        <td> attempted-user </td>
        <td> Попытка получения прав пользователя </td>
        <td> high </td>
      </tr>
      <tr>
        <td> inappropriate-content </td>
        <td> Обнаружено неприемлемое (несоответствующее) содержание </td>
        <td> high </td>
      </tr>
      <tr>
        <td> policy-violation </td>
        <td> Потенциальное нарушение корпоративной конфиденциальности </td>
        <td> high </td>
      </tr>
      <tr>
        <td> shellcode-detect </td>
        <td> Обнаружен исполняемый код </td>
        <td> high </td>
      </tr>
      <tr>
        <td> successful-admin </td>
        <td> Успешное получение прав администратора (повышение привилегий) </td>
        <td> high </td>
      </tr>
      <tr>
        <td> successful-user </td>
        <td> Успешное получение прав пользователя (повышение привилегий) </td>
        <td> high </td>
      </tr>
      <tr>
        <td> trojan-activity </td>
        <td> Обнаружена активность сетевой троянской программы </td>
        <td> high </td>
      </tr>
      <tr>
        <td> unsuccessful-user </td>
        <td> Неудачная попытка получения прав пользователя </td>
        <td> high </td>
      </tr>
      <tr>
        <td> web-application-attack </td>
        <td> Атака на Web-приложение </td>
        <td> high </td>
      </tr>
      <tr>
        <td> attempted-dos </td>
        <td> Предпринята попытка атаки отказ в обслуживании (DoS) </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> attempted-recon </td>
        <td> Попытка утечки информации (разведка) </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> bad-unknown </td>
        <td> Потенциально нежелательный траффик </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> default-login-attempt </td>
        <td> Попытка входа с помощью стандартного логина/пароля </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> denial-of-service </td>
        <td> Обнаружена атака отказ в обслуживании (DoS) </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> misc-attack </td>
        <td> Прочие атаки </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> non-standard-protocol </td>
        <td> Обнаружено использование нестандартного протокола или нестандартное событие </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> rpc-portmap-decode </td>
        <td> Decode of an RPC Query (Декодирован удалённый вызов процедуры (RPC)) (Обнаружен запрос RPC) </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> successful-dos </td>
        <td> Успешная DOS-атака </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> successful-recon-largescale </td>
        <td> Крупномасштабная утечка информации </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> successful-recon-limited </td>
        <td> Утечка информации </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> suspicious-filename-detect </td>
        <td> Обнаружено подозрительное имя файла </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> suspicious-login </td>
        <td> Обнаружена попытка входа с подозрительным логином </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> system-call-detect </td>
        <td> Обнаружено обращение к ядру системы (system call) (Обнаружен системный вызов) </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> unusual-client-port-connection </td>
        <td> Клиент использует нестандартный порт </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> web-application-activity </td>
        <td> Доступ к потенциально уязвимому Web-приложению </td>
        <td> medium </td>
      </tr>
      <tr>
        <td> icmp-event </td>
        <td> Общее событие ICMP </td>
        <td> low </td>
      </tr>
      <tr>
        <td> misc-activity </td>
        <td> Прочая активность </td>
        <td> low </td>
      </tr>
      <tr>
        <td> network-scan </td>
        <td> Обнаружена попытка сканирования сети </td>
        <td> low </td>
      </tr>
      <tr>
        <td> not-suspicious </td>
        <td> Не являющийся подозрительным траффик </td>
        <td> low </td>
      </tr>
      <tr>
        <td> protocol-command-decode </td>
        <td> Generic Protocol Command Decode (Обнаружена попытка шифрования) (Обнаружена обычная команда протокола) </td>
        <td> low </td>
      </tr>
      <tr>
        <td> string-detect </td>
        <td> Обнаружена подозрительная строка </td>
        <td> low </td>
      </tr>
      <tr>
        <td> unknown </td>
        <td> Неизвестный траффик </td>
        <td> low </td>
      </tr>
      <tr>
        <td> tcp-connection </td>
        <td> Обнаружено TCP соединение </td>
        <td> very low </td>
      </tr>
    </tbody>
  </table>

  ***Синтаксис***: `classtype:<class name>;`

  ***Пример***:

    ```
    alert tcp any any -> any 25 (msg:"SMTP expn root"; flags:A+; content:"expn root"; nocase; classtype:attempted-recon;)
    ```


* **priority**

  Задаёт правилам уровень важности. Возможно использовать параметр priority вместе с classtype, при этом изменится уровень приоритета параметра classtype.

  ***Синтаксис***: `priority:<priority integer>;`

  ***Пример***:

    ```
    alert tcp any any -> any 80 (msg:"WEB-MISC phf attempt"; flags:A+; content:"/cgi-bin/phf"; priority:10;)
    ```

    ```
    alert tcp any any -> any 80 (msg:"EXPLOIT ntpdx overflow"; dsize:>128; classtype:attempted-admin; priority:10;)
    ```


* **metadata**

  Позволяет автору правил включать дополнительную информацию о правиле, как правило, в формате "ключ-значение". Ключи и значения тега metadata перечислены в таблице ниже:

  <table>
    <tbody>
      <thead>
        <tr>
          <th> Ключ </th>
          <th> Описание </th>
          <th> Формат значения </th>
        </tr>
      <thead>
      <tr>
        <td> engine </td>
        <td> Указывает правило библиотеки общего пользования (Indicate a Shared Library Rule) </td>
        <td> "shared" </td>
      </tr>
      <tr>
        <td> soid </td>
        <td> GID и SID правила библиотеки общего пользования (Shared Library Rule Generator and SID) </td>
        <td>sid </td>
      </tr>
      <tr>
        <td> service </td>
        <td> Идентификатор сервиса на основе цели (Target-Based Service Identifier) </td>
        <td> "http" </td>
      </tr>
    </tbody>
  </table>

  Отличные от указанных в таблице ключи Snort фактически игнорирует, поэтому они могут быть записаны в свободной форме в формате "ключ-значение". Несколько ключей подряд разделяются запятыми, а ключи и значения отделяются между собой пробелом.

  ***Синтаксис***:

    ```
    metadata:key1 value1;
    metadata:key1 value1, key2 value2;
    ```

  ***Пример***:

    ```
    alert tcp any any -> any 80 (msg:"Shared Library Rule Example"; metadata:engine shared; metadata:soid 3|12345;)
    ```

    ```
    alert tcp any any -> any 80 (msg:"Shared Library Rule Example"; metadata:engine shared, soid 3|12345;)
    ```

    ```
    alert tcp any any -> any 80 (msg:"HTTP Service Rule Example"; metadata:service http;)
    ```


#### Payload

* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****

#### Non-payload

* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****


#### Post-detection

* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
* ****
